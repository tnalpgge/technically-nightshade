<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content><link href="https://fonts.googleapis.com/css?family=Open+Sans:400|Old+Standard+TT:400&display=swap" rel=stylesheet media=print type=text/css onload='this.media="all"'><title>Generating Royal History</title><link rel=canonical href=https://tnalpgge.github.io/technically-nightshade/posts/generating-royal-history/><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:700px;margin:auto}p{margin:20px 0}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:12px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:12px}#content h1{font-size:20px}#content h2{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style></head><body><section id=nav><h1><a href=/></a></h1><ul><li><a href=/technically-nightshade/>Technically Nightshade</a></li><li><a href=/technically-nightshade/posts/>Posts</a></li><li><a href=/technically-nightshade/posts/generating-royal-history/>Generating Royal History</a></li><li><a href=/technically-nightshade/posts/sdrawkcab-gnitirw/>sdrawkcaB gnitirW</a></li></ul></section><section id=content><h1>Generating Royal History</h1><div id=sub-header>December 2022 Â· 14 minute read</div><div class=entry-content><p>Recently I found myself in a bit of a bind as someone who wants to write homebrew content for a very popular tabletop role-playing game. As is so common in many fantasy settings, there is some sort of feudal system, and there is some history of rulers, possibly with noble houses vying for power. I had arbitrarily selected &ndash; with the help of the <a href=https://donjon.bin.sh/fantasy/calendar/>donjon Fantasy Calendar Generator</a> &ndash; that the year in the setting was in the very late 600s. But the information that I had posted on the web site for the setting said that the current year was in the mid-800s! And I already had the names of the current rulers and their predecessors back for 250 years or so published to the setting web site.</p><p>Fortunately for me, a lot of that information is just background and hasn&rsquo;t actually been used in-game yet. I decided to take the existing record of recent rulers from the same house and shift it to match my desired end date. But that left a gap of almost 200 years, and I had to ensure that the succession wasn&rsquo;t totally bonkers during that time.</p><p>Since I had used a very unsophisticated random generator on the previous iteration, I figured I&rsquo;d codify and improve it. And because I was planning out my campaign in <a href=https://orgmode.org/>org-mode</a> files, I could get <a href=https://www.gnu.org/software/emacs/>Emacs</a> to generate stuff right there in my document.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> And augment my existing table containing a human-friendly version of the royal historian&rsquo;s official account to treat a few columns in a more spreadsheet-like manner. I could then publish the table minus a few key columns on the setting&rsquo;s web site and things would be golden.</p><p>First, the matter of the royal historian&rsquo;s official account. While I am no wizard at Emacs Lisp, I know enough of it and Emacs self-documenting facilities to bludgeon my way to something that works.</p><p>I will spare you the long saga of actually writing the generator and just present the finished bits of code, with commentary interspersed. In my original document, all of the Emacs Lisp code for generating the royal historian&rsquo;s account is in a single <code>#+begin_src elisp</code> &mldr; <code>#+end_src</code> block.</p><p>I knew that I wanted to organize my generator by separating the data from the code, so I started out by plotting the fixed points.</p><pre><code class=language-elisp>(setq reign/houses '(gondal zaman ashkani sial
			  psarlay qambrani malyar
			  jalbani baloch nazdana rodini))
</code></pre><p>The first such fixed points were the names of the royal houses vying for the throne. I sourced them all from artisanal button-mashing on <a href=https://www.fantasynamegenerators.com/>Fantasy Name Generators</a>. (To protect the <del>guilty</del> innocent, the names I give in this article are a bit different than the ones I use in the campaign.)</p><p>I found that using <code>defvar</code> instead of <code>setq</code> got in the way of frequent re-evaluation of the code block. If this were code that I planned to distribute to others in a convenient form then I would learn all the nuances of the various ways of setting variables or constants, but this is really for my own convenience.</p><p>Occasionally one house cannot hold on to the throne, and they are deposed. I decided that there was a roughly 1 in 3 chance of the throne changing hands when a ruler&rsquo;s reign ended, so I expressed that as a list of booleans from which I would eventually select a random element. <code>nil</code> means the throne remains with the same house when the ruler changes. <code>t</code> indicates a change of house, and possibly a bloody and messy interregnum. (But I will leave that to the professionals to describe in gory detail.)</p><pre><code class=language-elisp>(setq reign/maybe-change-of-house (list nil nil t))
</code></pre><p>There are many gender expressions in our modern world, and there are almost as many in this fantasy setting. Because our nobles aren&rsquo;t the most enlightened people by modern standards, it is more common for them to have male rulers. But female rulers are known to happen, and once in a while a ruler may eschew traditional gender (<code>x</code>) altogether. (It&rsquo;s good to be the <del>king</del> <del>queen</del> monarch!) So we&rsquo;ll assemble another table of probabilities: 3/6 male (<code>m</code>), 2/6 female (<code>f</code>), 1/6 other (<code>x</code>).<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><pre><code class=language-elisp>(setq reign/ruler-genders '(m m m f f x))
</code></pre><p>Sometimes a ruler may take a consort, and sometimes they won&rsquo;t. I arbitrarily decided that it was a little more likely that they would have one (<code>t</code>) than not (<code>nil</code>).</p><pre><code class=language-elisp>(setq reign/maybe-has-consort (list t t t nil nil))
</code></pre><p>And if the ruler took a consort, would the consort&rsquo;s gender match the ruler&rsquo;s? More likely that the ruler and their consort would be a heterosexual couple (<code>nil</code>). But we allow for same-gender couples (<code>t</code>) and even a consort who doesn&rsquo;t exhibit traditional gender (<code>x</code>).</p><pre><code class=language-elisp>(setq reign/maybe-consort-gender (list nil nil nil nil nil t t t 'x))
</code></pre><p>To encourage some variation in the length of a ruler&rsquo;s reign, we&rsquo;ll roll 2d36. Some reigns are short, some are long, most fall in the middle.</p><pre><code class=language-elisp>(defun reign/duration () (+ (random 36) (random 36)))
</code></pre><p>Does another house steal the throne when the ruler changes? If so, what house? We can&rsquo;t choose the same house as we started with so <code>reign/change-of-house</code> will keep picking until we get something different. The <code>seq-random-elt</code> function is quite literally the backbone of our generator, choosing one element at random from the sequence given as its argument. Yes, the variables above were explicitly chosen with this function in mind.</p><p>Since this is Lisp, you will be seeing a lot of recursive functions from here on out!</p><pre><code class=language-elisp>(defun reign/new-house () (seq-random-elt reign/maybe-change-of-house))

(defun reign/house () (seq-random-elt reign/houses))

(defun reign/change-of-house (old-house)
  (let ((new-house (reign/house)))
    (if (eq new-house old-house)
      (reign/change-of-house old-house)
      new-house)))
</code></pre><p>Now we get to the sticky matter of the gender of the ruler, if they have a consort, and the gender of their consort. A lookup table for <code>reign/consort-gender-lookup</code> would have been difficult to understand, but as a function I can express the intent much more clearly. <code>x</code> means that the consort is ender non-conforming, <code>t</code> means that the ruler and consort are the same gender, <code>nil</code> means a more traditional couple.</p><pre><code class=language-elisp>(defun reign/ruler-gender () (seq-random-elt reign/ruler-genders))

(defun reign/has-consort () (seq-random-elt reign/maybe-has-consort))

(defun reign/consort-gender () (seq-random-elt reign/maybe-consort-gender))

(defun reign/consort-gender-lookup (ruler consort)
  (cond ((eq consort 'x) consort)
      ((and (eq ruler 'm) (not consort)) 'f)
      ((and (eq ruler 'f) (not consort)) 'm)
      (t ruler)))

(defun reign/consort-gender (ruler-gender)
  (let ((consort-gender (seq-random-elt reign/maybe-consort-gender)))
    (reign/consort-gender-lookup ruler-gender consort-gender)))
</code></pre><p>So with all of our data structures defined, and a bunch of helper functions in the bag, we can generate one ruler&rsquo;s reign. We&rsquo;ll express it as an alist, a list of pairs. The first element of each pair will be a human-friendly name of an attribute of a ruler&rsquo;s reign; the second element will be the associated value.</p><pre><code class=language-elisp>(defun reign/generate-one (current-house)
  (let* ((duration (reign/duration))
       (next-house (if (reign/new-house) (reign/change-of-house current-house) current-house))
       (ruler-gender (reign/ruler-gender))
       (has-consort (reign/has-consort))
       (consort-gender (reign/consort-gender ruler-gender)))
    (list
     (cons 'duration duration)
     (cons 'house next-house)
     (cons 'ruler-gender ruler-gender)
     (cons 'consort-gender (if has-consort consort-gender 'no-consort)))))
</code></pre><p>So we can generate a bunch of reigns that are disconnected from each other. What we really wanted to do was fill a gap of a certain duration, knowing the start and end years, and the ruler&rsquo;s house as of the end year.</p><p>Another recursive function to the rescue, this time one that keeps track of our history. Instead of going forwards in time, this one goes backwards from the end, treating history as a stack, and we push older and older reigns onto the front of it.</p><p>Our recursion base case can be when <code>end-year</code>, which we redefine on each recursion, has reached or overshot the <code>start-year</code>. In that case we just return the accumulated <code>history</code> and say we have completed our task.</p><p>If we&rsquo;ve still got a ways to go, we can use <code>reign/generate-one</code> to generate the next earlier reign, and start picking it apart to make sure it doesn&rsquo;t run afoul of <code>start-year</code>, adjusting its professed duration and end year if necessary. Then we can augment the generated reign record with this additional information, add it to the front of our history, and continue to recurse back in time. The functions <code>alist-get</code> and <code>assoc-delete-all</code> help us craft the adjusted reign record.</p><pre><code class=language-elisp>(defun reign/generate-helper (start-year start-house end-year history)
  (if (&lt;= end-year start-year) history
    (let* ((this-reign (reign/generate-one start-house))
	 (house (alist-get 'house this-reign))
	 (maybe-duration (alist-get 'duration this-reign))
	 (duration-floor (- end-year start-year))
	 (maybe-new-end-year (- end-year maybe-duration))
	 (adjusted-duration (if (&lt; maybe-new-end-year start-year) duration-floor maybe-duration))
	 (new-end-year (if (&lt;= maybe-new-end-year start-year) start-year maybe-new-end-year))
	 (augmentation (list
			(cons 'start-year new-end-year)
			(cons 'end-year end-year)))
	 (adjusted-duration-pair (cons 'duration adjusted-duration))
	 (durationless-reign (assoc-delete-all 'duration this-reign))
	 (adjusted-reign (cons adjusted-duration-pair durationless-reign))
	 (reign-record (append augmentation adjusted-reign))
	 (new-history (cons reign-record history)))
      (reign/generate-helper start-year house new-end-year new-history))))
</code></pre><p>Now we can fill in the gap that we were so worried about!</p><pre><code class=language-elisp>(setq reign/start-gap 611)
(setq reign/end-house 'malyar)
(setq reign/end-gap 784)

(defun reign/generate-gap ()
  (reign/generate-helper reign/start-gap reign/end-house reign/end-gap nil))
</code></pre><p>And since we have this useful code that allows us to plug in any values we want, we may as well generate rulers back to the beginning of time&mldr;or at least back to the beginning of recorded history.</p><pre><code class=language-elisp>(setq reign/start-ancient 1)
(setq reign/end-ancient-house 'baloch)
(setq reign/end-ancient 421)

(defun reign/generate-ancient ()
  (reign/generate-helper reign/start-ancient reign/end-ancient-house reign/end-ancient nil))
</code></pre><p>And just glue all that history together.</p><pre><code class=language-elisp>(append (reign/generate-ancient) (reign/generate-gap))
</code></pre><p>The really magical part is when you put all that code into the same block and type <code>C-c C-c</code> (Control-C, twice) on the block, which runs <code>org-babel-execute-src-block</code> and evaluates it. At the bottom appears the result in a handy table form! Each entry looks something like this:</p><pre><code class=language-org>| (start-year . 665) | (end-year . 713) | (duration . 48) | (house . psarlay)    | (ruler-gender . f) | (consort-gender . m)          |
</code></pre><p>Determining names for the ruler and their consort is a very separate and more subjective process. But we have taken a model and generated some fantasy kingdom history with it!</p><p>As for publishing this information, we can get the spreadsheet features of org-mode to help us out, if we structure our table properly. The published table on the web site looks something like this:</p><pre><code class=language-org>| Years        | House   | Ruler(s)                             |
|--------------+---------+--------------------------------------|
| 665-713 X.Y. | Psarlay | Queen Zakia &amp; Prince Consort Sangrez |
</code></pre><p>But I have start years and durations and end years in the data I just generated. Why not ask Emacs to format things for us? My private copy of the table looks like this:</p><pre><code class=language-org>| Start | Duration | End | Years | House   | Ruler(s)                             |
|-------+----------+-----+-------+---------+--------------------------------------|
|   665 |       48 |     |       | Psarlay | Queen Zakia &amp; Prince Consort Sangrez |
#+TBLFM: $3 = if($2, $1 + $2, string(&quot;&quot;))
#+TBLFM: $4 = '(concat $1 &quot;-&quot; $3 &quot; X.Y.&quot;)
</code></pre><p>Whenever I type that lovely <code>C-c C-c</code> (<code>org-ctrl-c-ctrl-c-hook</code>) on each <code>#+TBLFM:</code> line it fills in the cells that are derived information in a consistent format. (Probably eventually running <code>org-table-calc-current-TBLFM</code>.) Or I can use <code>C-c *</code> (<code>org-ctrl-c-star</code> which eventually calls <code>org-table-recalculate</code>) from within the table to recompute all the formulas associated with it. So I can then copy this table to the web site &ndash; also written in org, because I&rsquo;m lazy and the <a href=https://github.com/github/markup>Github Markup library</a> that powers Github wikis supports it &ndash; and just remove the first three columns of the table by moving my cursor to each column and invoking <code>M-x org-table-delete-column</code>.</p><h2 id=complete-source>Complete Source</h2><p>Save this in a file whose name ends in <code>.org</code>. Wrap the code in <code>#+begin_src elisp</code> and <code>#+end_src</code> and evaluate.</p><pre><code class=language-elisp>(setq reign/houses '(gondal zaman ashkani sial
			  psarlay qambrani malyar
			  jalbani baloch nazdana rodini))
(setq reign/maybe-change-of-house (list nil nil t))
(setq reign/ruler-genders '(m m m f f x))
(setq reign/maybe-has-consort (list t t t nil nil))
(setq reign/maybe-consort-gender (list nil nil nil nil nil t t t 'x))

(defun reign/duration () (+ (random 36) (random 36)))

(defun reign/new-house () (seq-random-elt reign/maybe-change-of-house))

(defun reign/house () (seq-random-elt reign/houses))

(defun reign/change-of-house (old-house)
  (let ((new-house (reign/house)))
    (if (eq new-house old-house)
      (reign/change-of-house old-house)
      new-house)))

(defun reign/ruler-gender () (seq-random-elt reign/ruler-genders))

(defun reign/has-consort () (seq-random-elt reign/maybe-has-consort))

(defun reign/consort-gender () (seq-random-elt reign/maybe-consort-gender))

(defun reign/consort-gender-lookup (ruler consort)
  (cond ((eq consort 'x) consort)
      ((and (eq ruler 'm) (not consort)) 'f)
      ((and (eq ruler 'f) (not consort)) 'm)
      (t ruler)))

(defun reign/consort-gender (ruler-gender)
  (let ((consort-gender (seq-random-elt reign/maybe-consort-gender)))
    (reign/consort-gender-lookup ruler-gender consort-gender)))

(defun reign/generate-one (current-house)
  (let* ((duration (reign/duration))
       (next-house (if (reign/new-house) (reign/change-of-house current-house) current-house))
       (ruler-gender (reign/ruler-gender))
       (has-consort (reign/has-consort))
       (consort-gender (reign/consort-gender ruler-gender)))
    (list
     (cons 'duration duration)
     (cons 'house next-house)
     (cons 'ruler-gender ruler-gender)
     (cons 'consort-gender (if has-consort consort-gender 'no-consort)))))

(defun reign/generate-helper (start-year start-house end-year history)
  (if (&lt;= end-year start-year) history
    (let* ((this-reign (reign/generate-one start-house))
	 (house (alist-get 'house this-reign))
	 (maybe-duration (alist-get 'duration this-reign))
	 (duration-floor (- end-year start-year))
	 (maybe-new-end-year (- end-year maybe-duration))
	 (adjusted-duration (if (&lt; maybe-new-end-year start-year) duration-floor maybe-duration))
	 (new-end-year (if (&lt;= maybe-new-end-year start-year) start-year maybe-new-end-year))
	 (augmentation (list
			(cons 'start-year new-end-year)
			(cons 'end-year end-year)))
	 (adjusted-duration-pair (cons 'duration adjusted-duration))
	 (durationless-reign (assoc-delete-all 'duration this-reign))
	 (adjusted-reign (cons adjusted-duration-pair durationless-reign))
	 (reign-record (append augmentation adjusted-reign))
	 (new-history (cons reign-record history)))
      (reign/generate-helper start-year house new-end-year new-history))))

(setq reign/start-gap 611)
(setq reign/end-house 'malyar)
(setq reign/end-gap 784)

(defun reign/generate-gap ()
  (reign/generate-helper reign/start-gap reign/end-house reign/end-gap nil))

(setq reign/start-ancient 1)
(setq reign/end-ancient-house 'baloch)
(setq reign/end-ancient 421)

(defun reign/generate-ancient ()
  (reign/generate-helper reign/start-ancient reign/end-ancient-house reign/end-ancient nil))

(append (reign/generate-ancient) (reign/generate-gap))
</code></pre><h2 id=sdrawkcab-gnitirw>sdrawkcaB gnitirW troff</h2><p>I am no fan of modern office software. I use it under protest and under duress. It&rsquo;s important software to a lot of people, but it feels like dragging a steamer trunk crammed full of clothes and equipment to the corner store at the end of the block when you just want a quick snack. So I look for alternatives in free, <em>libre,</em> and open-source software that are compatible with revision control systems for text files; they can run quite well on older and lower-spec machines.</p><p>When I was sufficiently inspired to write an entire adventure for a popular tabletop role-playing game, I started to look for a way to produce an attractive PDF document with the familiar two-column layout that so many publishers use. I had seen troff used for manual pages, and I had access to plenty of systems that had <a href=https://www.gnu.org/software/groff/>GNU roff</a> installed. (I had briefly played with <a href=https://www.ctan.org/tex>\TeX</a> and its descendant \LaTeX back in my university days, and I have a lot of respect for them, but they are not for me.) Since <a href=https://www.freebsd.org/>FreeBSD</a> had evicted many <a href=https://www.gnu.org/licenses/licenses.html#GPL>GPL</a>-licensed tools from their base system since the last time I did any serious <code>roff</code>-ing, I&rsquo;d have to find some useful software to install. Fortunately I stumbled upon the <a href=https://n-t-roff.github.io/heirloom/doctools>Heirloom Documentation Tools</a> (&ldquo;heirloom-doctools&rdquo;). They had me at <em>&ldquo;Plug-and-Play&rdquo; font handling</em> which means that a wide range of fonts was now open to me. (I vaguely remember using custom fonts in groff was painful.</p><p>I thought that I might use a mix of my usual left-to-right text with tiny sprinkles of right-to-left Hebrew in the adventure. This led me to briefly consider <a href=https://github.com/aligrudi/neatroff>neatroff</a>, but that would require a change in toolset that I wasn&rsquo;t prepared to accept. I ultimately punted on the idea, but I was left with an interesting question. Given that it can deal with UTF-8, <strong>could I teach heirloom-doctools to reverse strings for me?</strong></p><p>As with many problems involving a collection of things, there is a recursive approach and an iterative approach. One cannot truly say one has reversed a string until one has implemented both in the same language. Since I do virtually all of my writing in <a href=https://www.gnu.org/software/emacs>Emacs</a> these days, and Emacs Lisp (well, any Lisp really) lends itself to recursion, I&rsquo;ll start with the recursive version.</p><pre><code class=language-nroff>.\&quot;
.\&quot; Recursively build a reversed string
.\&quot;
.de REVRCSV \&quot; string text
.if '\\$2'' .return
.lds orig \\$2
.lds tail \\*[orig]
.substring tail -1
.ie '\\*[tail]' ' .as \\$1 \ \&quot; intentional space at end of line
.el .as \\$1 \\*[tail]
.chop orig
.REVRCSV \\$1 &quot;\\*[orig]&quot;
..
</code></pre><p>Contrast with the iterative version.</p><pre><code class=language-nroff>.\&quot;
.\&quot; Iteratively build a reversed string
.\&quot;
.de REVITER \&quot; string text
.ds \\$1
.lds orig \\$2
.length reviter \\*[orig]
.while \\n[reviter]&gt;0 \{\
.lds tail \\*[orig]
.substring tail -1
.ie '\\*[tail]' ' .as \\$1 \ \&quot; intentional space at end of line
.el .as \\$1 \\*[tail]
.chop orig
.length reviter \\*[orig]
\}
..
</code></pre><p>The calling convention for both is to define a string to store the result and to provide the text to be reversed. Then you can use the new string in other ways, or perhaps immediately place it in the output.</p><pre><code class=language-nroff>.do xflag 3
.lc_ctype en_US.UTF-8
.hylang en_US
.mediasize letter
.\&quot; insert macro definitions here
.REVRCSV rrr troff
.br
recursively: \*[rrr]
.REVITER iii troff
.br
iteratively: \*[iii]
</code></pre><p>Save the file as <code>ffort.tr</code> and compute your reversed strings!</p><pre><code class=language-text>$ nroff ffort.tr  | uniq
recursively: ffort
iteratively: ffort
</code></pre><p>Both the recursive and versions are about the same length, which is moderately surprising. And so far neither version has been directly useful in my writing as of yet, but I remain hopeful. Benchmarking them, I found that 10,000 iterations of the iterative version took about 4.5 seconds on my machine, and only 1,000 iterations of the recursive version took about 16.6 seconds. The iterative version is clearly faster. I still think the recursive version is more fun.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Yes, <a href=https://orgroam.com/>org-roam</a> is involved, but it is not the focus of this article.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Non-binary, transgender, and gender-non-conforming folk are welcome as players at the table and as characters in the setting as well. Modeling both sex and gender in the code would not add much educational value from a computing perspective, but could be interesting for describing a society that more closely resembles where I live.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div id=links><a href=https://tnalpgge.github.io/technically-nightshade/posts/sdrawkcab-gnitirw/>sdrawkcaB gnitirW&nbsp;&#187;</a></div></section></body></html>